#!/usr/bin/env lua

local split = require( "split" ).split -- TODO remove dependency

local function string_starts( str, start )
   return string.sub( str, 1, #start ) == start
end

local function table_tail( t, n )
   n = n or 1
   if # t <= n then return {} end

   local result = {}
   for i, v in ipairs( t ) do
      if i > n then
         table.insert( result, v )
      end
   end

   return result
end 

local function logfln( str, ... )
   return print( str:format( ... ) )
end

local function errfln( str, ... )
   return io.stderr:write( str:format( ... ), "\n" )
end

--------------------------------------------------------------------------------

local function check_number( i, tab )
   local n = tonumber( i )

   if n == nil then
      errfln( "Error: %q is not a number.", i )
      os.exit( false )
   end

   if n < 1 and n > #tab then
      errfln( "Error: %q is out of range[1-%i]", n, #tab )
      os.exit( false )
   end

   return n
end

local function get_path( args )
   local mode = "-g"
   if string_starts( args[ 1 ], "-" ) then
      mode = args[ 1 ]
      args = table_tail( args )
   end

   local path = ""
   if mode == "-g" then
      path = split( os.getenv( "PATH" ), ":" )
   elseif mode == "-i" then
      path = split( io.read(), ":" )
   else
      errfln( "Error: %q is not a valid mode to read the PATH", mode )
      errfln( "Use -g to read the PATH variable or -i to read from the input stream." )
      errfln( "The default value will be -g" )
      os.exit( false )
   end
   return path, args
end

local function set_path( path )
   local pathStr = table.concat( path, ":" ) -- TODO handle paths with spaces
   logfln( pathStr )
end

--------------------------------------------------------------------------------

local function insert( path, i, pv )
   local n = check_number( i, path )
   -- TODO check pv
   table.insert( path, i, pv )
   set_path( path )
end

local function list( path )
   if #path == 0 then
      logfln( "The PATH is empty" )
      os.exit( true )
   end

   for k,v in ipairs( path ) do
      logfln( "%i\t%s", k, v )
   end
end

local function push( path, pv )
   if pv == nil then
      errfln( "Error: The push command requires at least one valid path as parameter" )
      errfln( "Example: pato push ~/bin" )
   end
   -- TODO check pv
   table.insert( path, pv )
   set_path( path )
end

local function pushf( path, pv )
   if pv == nil then
      errfln( "Error: The pushf command requires at least one valid path as parameter" )
      errfln( "Example: pato pushf ~/bin" )
      os.exit( false )
   end
   -- TODO check pv
   table.insert( path, 1, pv )
   set_path( path )
end

local function remove( path, i )
   if i == nil then
      errfln( "Error: The remove command requires one valid index parameter." )
      errfln( "Example: pato remove 2" )
   end
   local n = check_number( i, path )
   table.remove( path, n )
   set_path( path )
end

local function swap( path, i1, i2 )
   if i1 == nil or i2 == nil then
      errfln( "Error: The swap cammand requires two valid index parameter." )
      errfln( "Example: pato swap 2 5" )
      os.exit( false )
   end

   local n1 = check_number( i1, path )
   local n2 = check_number( i2, path )

   local tmp = path[ n1 ]
   path[ n1 ] = path[ n2 ]
   path[ n2 ] = tmp

   set_path( path )
end

--------------------------------------------------------------------------------

if #arg < 1 then
   errfln( "Error: Use at least one subcommand." )
   os.exit( false )
end

local path, args = get_path( arg )

local cmd = args[ 1 ]

if cmd == "insert" then
   insert( path, args[ 2 ], args[ 3 ] )
elseif cmd == "list" then
   list( path )
elseif cmd == "push" then
   push( path, args[ 2 ] )
elseif cmd == "pushf" then
   pushf( path, args[ 2 ] )
elseif cmd == "remove" then
   remove( path, args[ 2 ] )
elseif cmd == "swap" then
   swap( path, args[ 2 ], args[ 3 ] )
else
   errfln( "%q is not a valid command", cmd )
end
